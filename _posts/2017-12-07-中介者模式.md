---
layout: post
title: “设计模式系列-中介者模式”
description: “设计模式”
category: 设计模式
tags: [android]
---
# 中介者

![s](/img/design/mediator.png)

Mediator 抽象中介者角色：<br/>
抽象中介者角色定义统一的接口，用于各同事角色之间的通信。<br/>
Concrete Mediator 具体中介者角色：<br/>
具体中介者角色通过协调各同事角色实现协作行为，因此它必须依赖于各个同事角色。<br/>
Colleague 同事角色：<br/>
每一个同事角色都知道中介者角色，而且与其他的同事角色通信的时候，一定要通过中介者角色协作。<br/>

//通用抽象中介者
public abstract class Mediator {
     //定义同事类
     protected ConcreteColleague1 c1;
     protected ConcreteColleague2 c2;
     public void setC1(ConcreteColleague1 c1) {
             this.c1 = c1;
     }
     public void setC2(ConcreteColleague2 c2) {
             this.c2 = c2;
     }
     //中介者模式的业务逻辑
     public abstract void doSomething1();
     public abstract void doSomething2();
}

//具体中介者
public class ConcreteMediator extends Mediator {
     @Override
     public void doSomething1() {
             //调用同事类的方法，只要是public方法都可以调用
             super.c1.selfMethod1();
             super.c2.selfMethod2();
     }
     public void doSomething2() {
             super.c1.selfMethod1();
             super.c2.selfMethod2();
     }
}

//抽象同事类
public abstract class Colleague {
     protected Mediator mediator;
     public Colleague(Mediator _mediator){
             this.mediator = _mediator;
     }
}

//具体同事类
public class ConcreteColleague1 extends Colleague {
     //通过构造函数传递中介者
     public ConcreteColleague1(Mediator _mediator){
             super(_mediator);
     }
     //自有方法 self-method
     public void selfMethod1(){
             //处理自己的业务逻辑
     }
     //依赖方法 dep-method
     public void depMethod1(){
             //处理自己的业务逻辑
             //自己不能处理的业务逻辑，委托给中介者处理
             super.mediator.doSomething1();
     }
}

中介者模式的优点：<br/>
中介者模式的优点就是减少类间的依赖，把原有的一对多的依赖变成了一对一的依赖，同事类只依赖中介者，减少了依赖，当然同时也降低了类间的耦合。<br/>

中介者模式的缺点：<br/>
中介者模式的缺点就是中介者会膨胀得很大，而且逻辑复杂，原本N个对象直接的相互依赖关系转换为中介者和同事类的依赖关系，同事类越多，中介者的逻辑就越复杂。<br/>




