---
layout: post
title: “设计模式系列-原型模式，备忘录模式”
description: “设计模式”
category: 设计模式
tags: [android]
---
# 原型模式

定义： 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

        public class PrototypeClass implements Cloneable{

             //覆写父类Object方法
             @Override
             public PrototypeClass clone(){
                     PrototypeClass prototypeClass = null;
                     try {
                            prototypeClass = (PrototypeClass)super.clone();
                     } catch (CloneNotSupportedException e) {
                            //异常处理
                     }
                     return prototypeClass;
             }
        }

原型模式已经与Java融为一体，大家可以随手拿来使用。

资源性能优化场景:<br/>
类初始化需要非常繁琐的数据准备，需要消化非常多的资源，这个资源包括数据、硬件资源等。<br/>
一个对象多个修改者的场景:<br/>
一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。<br/>

注意: <br/>
clone时构造函数不会被执行，Object类的clone方法的原理是从内存中（具体地说就是堆内存）以二进制流的方式进行拷贝，重新分配一个内存块，那构造函数没有被执行也是非常正常的了。

浅拷贝和深拷贝: <br/>
关于浅拷贝：

        public class Thing implements Cloneable{
             //定义一个私有变量
             private ArrayList arrayList = new ArrayList();

             @Override
             public Thing clone(){
                     Thing thing=null;
                     try {
                            thing = (Thing)super.clone();
                     } catch (CloneNotSupportedException e) {
                            e.printStackTrace();
                     }
                     return thing;
             }
             public void setValue(String value){
                     this.arrayList.add(value);
             }
             public ArrayList getValue(){
                     return this.arrayList;
             }
        }

Object类提供的方法clone只是拷贝本对象，其对象内部的数组、引用对象等都不拷贝，还是指向原生对象的内部元素地址，这种拷贝就叫做浅拷贝。<br/>
原始类型+装箱类型+String 会被拷贝，但其他的内部成员对象和数组不会拷贝，只会拷贝其引用。

关于深拷贝：

        public class Thing implements Cloneable{
             //定义一个私有变量
             private ArrayList arrayList = new ArrayList();
             @Override
             public Thing clone(){
                     Thing thing=null;
                     try {
                            thing = (Thing)super.clone();
                            thing.arrayList = (ArrayList)this.arrayList.clone();
                     } catch (CloneNotSupportedException e) {
                            e.printStackTrace();
                     }
                     return thing;
             }
        }

注意这里数组与ArrayList等clone，只会拷贝内部元素的引用数组，并不会深拷贝数组内部的元素。

关于一些其他的拷贝的姿势：

1.序列化（List深拷贝）

    public static List deepCopy(List src) throws IOException, ClassNotFoundException {
        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();
        ObjectOutputStream out = new ObjectOutputStream(byteOut);
        out.writeObject(src);

        ByteArrayInputStream byteIn = new ByteArrayInputStream(byteOut.toByteArray());
        ObjectInputStream in = new ObjectInputStream(byteIn);
        List dest = (List) in.readObject();
        return dest;
    }

2.System.arraycopy（数组的浅拷贝）

这个方法不是用java语言写的，而是底层用c或者c++实现的，因而速度会比较快。但是是浅拷贝

3.Arrays.copyOf（数组的浅拷贝）

调用的是System.arraycopy，如ArrayList的clone方法调用的就是Arrays.copyOf。

# 备忘录模式


